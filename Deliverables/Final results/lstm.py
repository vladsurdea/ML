# -*- coding: utf-8 -*-
"""LSTM

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kOiIjw3ns8gJ8SzYgh7RH9zHfm0mn88B

# **EDF with LSTM-based RNNs in Romania**

This implementation proposes the use of a LSTM-based RNN for the purpose of Electricity Demand Forecasting (EDF) in Romania.

# Data pre-processing
"""

# Commented out IPython magic to ensure Python compatibility.
#import the necessary packages

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import pprint
from matplotlib import style
from sklearn.preprocessing import MinMaxScaler
from keras.models import Sequential
from keras.layers import Dense,LSTM
from tensorflow.keras.layers import Dense, Dropout
# %matplotlib inline

#import the dataset from GitHub
url = "https://raw.githubusercontent.com/vladsurdea/ML/main/Data/RomaniaEDF.csv"
df= pd.read_csv(url)

#get rid of missing values

#inspect the dataset
df=df.dropna()
df.sample(10)

# create datetime variable
df["Datetime"]=pd.to_datetime(df[["Year", "Month", "Day", "Hour"]])
del df["Year"]
del df["Month"]
del df["Day"]
del df["Hour"]

#inspect the new dataset
df.sample(20)

# Other data wrangling steps
dataset=df
dataset["Month"] = pd.to_datetime(df["Datetime"]).dt.month
dataset["Year"] = pd.to_datetime(df["Datetime"]).dt.year
dataset["Date"] = pd.to_datetime(df["Datetime"]).dt.date
dataset["Time"] = pd.to_datetime(df["Datetime"]).dt.time
dataset["Week"] = pd.to_datetime(df["Datetime"]).dt.week
dataset["Day"] = pd.to_datetime(df["Datetime"]).dt.day_name()

#Set datetime variable as index
dataset = df.set_index("Datetime")
dataset.index = pd.to_datetime(dataset.index)
dataset.sample(10)

"""# Split dataset into testing and training data"""

TestData = NewDataSet.tail(100)

Training_Set = NewDataSet.iloc[:,0:1]

Training_Set = Training_Set[:-60]

Training_Set = Training_Set
sc = MinMaxScaler(feature_range=(0, 1))
Train = sc.fit_transform(Training_Set)

X_Train = []
Y_Train = []

for i in range(60, Train.shape[0]):
    X_Train.append(Train[i-60:i])
    Y_Train.append(Train[i])

X_Train = np.array(X_Train)
Y_Train = np.array(Y_Train)

X_Train = np.reshape(X_Train, newshape=(X_Train.shape[0], X_Train.shape[1], 1))
X_Train.shape

"""# Building the LSTM-based RNN"""

regressor = Sequential()

# Adding the first LSTM layer and some Dropout regularisation
regressor.add(LSTM(units = 50, return_sequences = True, input_shape = (X_Train.shape[1], 1)))
regressor.add(Dropout(0.2))

# Adding a second LSTM layer and some Dropout regularisation
regressor.add(LSTM(units = 50, return_sequences = True))
regressor.add(Dropout(0.2))

# Adding a third LSTM layer and some Dropout regularisation
regressor.add(LSTM(units = 50, return_sequences = True))
regressor.add(Dropout(0.2))

# Adding a fourth LSTM layer and some Dropout regularisation
regressor.add(LSTM(units = 50))
regressor.add(Dropout(0.2))

# Adding the output layer
regressor.add(Dense(units = 1))

# Compiling the LSTM-based RNN
regressor.compile(optimizer = 'adam', loss = 'mean_squared_error')

# Compiling the LSTM-based RNN
regressor.fit(X_Train, Y_Train, epochs = 100, batch_size = 32)

"""# Create predictions dataset"""

Df_Total = pd.concat((NewDataSet[["Value"]], TestData[["Value"]]), axis=0)

inputs = Df_Total[len(Df_Total) - len(TestData) - 60:].values

inputs = Df_Total[len(Df_Total) - len(TestData) - 60:].values
inputs = inputs.reshape(-1,1)
inputs = sc.transform(inputs)

X_test = []
for i in range(60, 160):
    X_test.append(inputs[i-60:i])
    
X_test = np.array(X_test)

X_test = np.reshape(X_test, (X_test.shape[0], X_test.shape[1], 1))

predicted = regressor.predict(X_test)

# Do inverse Transformation to get Values 
predicted = sc.inverse_transform(predicted)

True_MegaWatt = TestData["Value"].to_list()
Predicted_MegaWatt  = predicted
dates = TestData.index.to_list()

Machine_Df = pd.DataFrame(data={
    "Date":dates,
    "TrueMegaWatt": True_MegaWatt,
    "PredictedMeagWatt":[x[0] for x in Predicted_MegaWatt ]
})

Machine_Df

"""# Visualise results"""

plt.style.use('seaborn-pastel')
fig = plt.figure()

ax1= fig.add_subplot(111)

x = dates
y = True_MegaWatt

y1 = Predicted_MegaWatt

plt.plot(x,y, color="green")
plt.plot(x,y1, color="red")
# beautify the x-labels
plt.gcf().autofmt_xdate()
plt.xlabel('Dates')
plt.ylabel("Power in MW")
plt.title("Machine Learned the Pattern Predicting Future Values ")
plt.legend()



